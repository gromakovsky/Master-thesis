% -*-coding: utf-8-*-

Программное обеспечение всегда было и остаётся подвержено
ошибкам. Одними из наиболее уязвимых являются программы, написанные на
языках C и C++, поскольку они предоставляют прямой доступ к памяти и
не имеют встроенных механизмов для предотвращения некорректного
обращения к памяти. Пожалуй, наибольшую опасность представляют ошибки,
при которых происходит доступ к памяти (чтение или запись) за
пределами выделенного буфера. Такие ошибки могут приводить как к
остановке программы, так и к более серьёзным проблемам с точки зрения
безопасности. Например, злонамеренный пользователь может получить
доступ к приватной информации, исполнить произвольный код, а в худшем
случае получить права суперпользователя~\cite{onesmashing}.

Существует большое число подходов к решению данной проблемы, как
статических~\cite{wagner2000first, xie2003archer, ganapathy2003buffer,
le2008marple, li2010practical}, так и
динамических~\cite{cowan1998stackguard,
ruwase2004practical}. Динамические подходы обнаруживают ошибки во
время работы программы и имеют несколько серьёзных недостатков по
сравнению со статическими подходами, когда программа анализируется до
запуска. Во-первых, дополнительные проверки, выполняемые во время
работы программы, занимают какое-то время и тем самым ухудшают
производительность. Во-вторых, даже если ошибка будет обнаружена,
программа в лучшем случае просто остановится. В-третьих, зачастую
оказывается довольно сложно быстро внести изменения, направленные на
исправление ошибок, и донести их до конечного пользователя. Поэтому
гораздо предпочтительнее обнаружить ошибки до поставки программы
пользователю.

Основная цель данной работы состоит в разработке алгоритмов
статического анализа C/C++ программ на предмет выхода за пределы
динамического массива. При этом необходимо обрабатывать большие
программы, состоящие из сотен тысяч строк, за разумное время. В общем
случае задача поиска всех выходов за пределы массива без единого
ложного срабатывания неразрешима, поэтому анализатор должен находить
как можно больше реальных ошибок, при этом выдавая как можно меньше
ложных срабатываний.

За основу данной работы был взят подход, описанный в
статье~\cite{li2010practical}. Были выявлены преимущества и недостатки
предложенного подхода, предложены и реализованы способы решения
найденных недостатков. С помощью проделанных улучшений удалось
существенно уменьшить число ложных срабатываний, тем самым увеличив
точность анализа. Также было проведено сравнение с другими свободно
распространяемыми анализаторами, показано превосходство над
ними. Реализованный алгоритм способен обрабатывать программы,
состоящие из сотен тысяч строк, за время порядка десяти минут.

В первой главе приведён обзор предметной области и существующих
решений описанной проблемы. Во второй главе представлены результаты
исследования алгоритма из статьи~\cite{li2010practical}, описан
теоретический подход к устранению выявленных недостатков. В третьей
главе рассмотрены вопросы практической реализации предложенного
решения, приведены основные результаты работы и сравнение с другими
анализаторами.
