%-*-coding: utf-8-*-
\chapter{Обзор предметной области}

\section{Описание проблемы}

Ошибки в коде программного обеспечения могут представлять большую
опасность и приводить с серьёзным убыткам. Например, в 2003-ем году
большое число компьютеров по всему миру было заражено вирусом SQL
Slammer~\cite{moore2003spread}, что приводило к отказу оборудования и
существенному замедлению трафика в сети Интернет в целом. Другим
примером служит червь Code-Red, убытки от которого оцениваются
миллиардами долларов~\cite{moore2002code}. Оба вируса использовали
уязвимости в программном коде, позволявшие осуществить выход за
пределы массива. Такие ошибки являются одними из наиболее опасных,
поскольку зачастую злоумышленик может, используя уязвимость, выполнить
произвольный код и/или получить права
суперпользователя\cite{onesmashing}.

Наиболее актуальна данная проблема для языков C/C++. Дизайн этих
языков подразумевает высокую гибкость и производительность, жертвуя
безопасностью. Языки позволяют осуществлять произвольный доступ к
памяти и не имеют встроенных автоматических проверок корректности. Для
многих приложений данный недостаток является менее существенным, чем
производительность, поэтому языки C и C++ активно используются и по
сей день. Многие операционные системы написаны на C/C++ из соображений
гибкости и производительности. Также существует большое число
программ, работающих с сетью и получающих данные извне, написанных на
C/C++ из соображений производительности. Уязвимости в таком
программном обеспечении являются крайне опасными, поскольку
операционные системы работают напрямую с аппаратными средствами, а
ошибки в сетевых приложениях могут быть эксплуатированы удалённо
фактически любым человеком.

В данной работе под выходом за пределы динамического массива
подразумевается обращение (чтение и запись) к памяти за пределами
выделенного участка памяти. Если существуют такие входные данные (то
есть любые данные, неизвестные заранее), что при запуске программы с
такими входными данные в ней присутствует инструкция, совершающая
выход за пределы массива, то такая инструкция считается ошибочной и
потенциально уязвимой. Задача состоит в поиске таких инструкций.

В связи с актуальностью проблемы ей уделено большое внимание учёных и
инженеров по всему миру. Известно большое число подходов к решению
данной задачи. Глобально их можно разделить на динамические и
статические.

Динамические подходы~\cite{cowan1998stackguard, ruwase2004practical,
  hastings1991purify} состоят в добавлении в программу дополнительных
проверок, предотвращающих обращение к памяти за пределами выделенного
буфера. Основное преимущество этого подхода в том, что он, как
правило, предотвращает большее число ошибок, поскольку значения всех
переменных известны в момент обращения к памяти. Однако такие подходы
существенно замедляют работу программы, что зачастую оказывается
неприемлимо в случаях, когда производительность стоит на первом
месте. Другим недостатком динамического подхода является тот факт, что
при наличии ошибки она будет обнаружена уже во время программы, что,
скорее всего, приведёт к остановке. Также динамические подходы
способны находить лишь ошибки, которые воспроизводятся на реально
выполняемых участках кода. На практике же нередко происходит так, что
какой-то фрагмент кода может не выполняться на протяжении очень
длительного времени, однако именно в нём может быть ошибка, которая
очень долго будет оставаться незамеченной.

Статический анализ, в отличие от динамического, производится без
запуска программы. Это позволяет исследовать все места в коде, даже
редко выполняемые, а также позволяет найти ошибки до реального
использования программы, пока они не проявили себя. Помимо этого
статический анализ никак не меняет исполняемый код, а значит, не
замедляет программу. В общем случае задача поиска всех выходов за
пределы массива в C/C++ без единого ложного срабатывания неразрешима
(это напрямую следует из проблемы
останова~\cite{turing1937computable}), поэтому одним из главных
недостатков статического анализа является необходимость ручного
рассмотрения результатов работы анализатора с целью выяснения, какие
из найденных ошибок действительно являются таковыми.

Таким образом, динамические и статические подходы имеют свои
преимущества и недостатки. В разных случаях имеет смысл применять
разные подходы (в том числе комбинацию подходов). Оба варианта
являются осмысленными и актуальными. В данной работе был сделан выбор
в пользу статического анализа. Поскольку задача неразрешима в общем
случае, требуется находить как можно больше ошибок в программах,
минимизируя при этом число ложных срабатываний. Важным требованием
является способность обрабатывать крупные программы, состоящие из
сотен тысяч строк, за разумное время. Как правило, приемлимым является
время порядка нескольких десятков минут. Это сопоставимо со временем
сборки проекта и позволяет, например, включить анализатор в систему
непрерывной интеграции.

Несмотря на огромное число исследований, посвящённых данной проблеме,
уязвимости, связанные с выходом за пределы массива продолжают
оставаться одними из наиболее часто встречаемых~\cite{uscert}. Таким
образом, на сегодняшний день задача не перестаёт быть
актуальной. Также стоит отметить, что большое число подходов,
описанных в статьях, находятся в закрытом доступе или же
поддерживаются на протяжении долгих лет. Большинство доступных
анализаторов решают более общую проблему поиска различных ошибок и
либо работают слишком долго на больших программах, либо находят
слишком мало ошибок, связанных с выходами за пределы массива.

\section{Обзор существующих решений}

TODO: написать про всякие конкретные статические подходы.

\section{Обзор статьи~\cite{li2010practical}}

На основании проведённого изучения литературы было принято решение
использовать алгоритм, описанный в статье \cite{li2010practical} в
качестве базового. Во-первых, этот подход является легковесным, что
позволяет достаточно быстро обрабатывать большие программы. Во-вторых,
результаты, представленные в статье, говорят о том, что анализатор
способен находить много ошибок в крупных открытых проектах. В-третьих,
несмотря на довольно хорошие результаты, авторы также отмечают наличие
ложных срабатываний и спорных ситуаций, в которых алгоритм не может
принять однозначное решение. А значит, у этого подхода есть
пространство для улучшений.

TODO: описать основную суть подхода из статьи.

\chapterconclusion

В данной главе была подробно описана проблема выхода за пределы
динамического массива в C/C++ программах, показана её
актуальность. Был приведён обзор существующих решений этой проблемы,
описаны ключевые характеристики различных статических подходов. Был
обоснован выбор алгоритма из статьи~\cite{li2010practical} в качестве
базового подхода для данной работы, приведён более подробный обзор
этого алгоритма.
