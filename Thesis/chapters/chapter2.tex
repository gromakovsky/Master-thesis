%-*-coding: utf-8-*-
\chapter{Теоретическое исследование}

В данной работе было проведено подробное исследование подхода,
представленного в статье~\cite{li2010practical}. В связи с отсутствием
реализации описанного алгоритма в открытом доступе он был реализован с
нуля в полном соответствии с приведённом в статье описанием. В ходе
исследования основное внимание было уделено недостаткам этого
подхода. Были выявлены случаи, в которых описанный алгоритм работает
некорректно. Ниже представлено описание таких случаев, а также
предложены способы решения этих проблем.

\section{Обработка циклов}

В данном разделе описаны две проблемы, связанные с обработкой
циклов.

\subsection{Монотонно изменяющиеся переменные}

\begin{figure}
    \includegraphics[]{for-trivial.png}
    \caption{Простой цикл: C++}
    \label{fig:for-trivial-cpp}
\end{figure}

\begin{figure}
    \inputTikZ{for-trivial}
    \caption{Простой цикл: SSA форма}
    \label{fig:for-trivial-ssa}
\end{figure}

На рисунке~\ref{fig:for-trivial-cpp} представлен фрагмент C++ кода с
простым циклом, в котором значение переменной $x$ меняется от нуля до
девяти включительно. На рисунке~\ref{fig:for-trivial-ssa} представлена
соответствующая ему SSA форма.

В данном случае алгоритм, описанный в статье~\cite{li2010practical},
будет работать следующим образом. Для проверки корректности записи в
массив будет посчитан диапазон возможных значений переменной $x$ в
месте записи в массив. Для этого сначала будет посчитан диапазон
значений $x$ в месте определения. Изначально в качестве диапазона
будет взят $[\bot, \top]$. Поскольку $x$ выражается как
$\phi$-инструкция, необходимо посчитать диапазон значений $x_1$ в
месте определения $x$ и объединить с $[0, 0]$ (диапазоном значений
второго аргумента). Диапазон значений $x_1$ вычисляется через диапазон
значений $x$ в месте определения $x_1$. Изначально для $x$ был взят
отрезок $[\bot, \top]$, однако в месте определения $x_1$ также будет
применён предикат $x < 10$. Таким образом, диапазон значений $x_1$
будет $[\bot, 10]$. Объединяя его с $[0, 0]$, получаем $[\bot, 10]$ и
для $x$. Это значит, что в данном примере анализатор посчитает, что
$x$ может быть отрицательным, а значит, запись в массив
некорректна. Однако нетрудно видеть, что в действительности это не
так, $x$ не может быть меньше нуля, а запись в массив всегда
корректна. Таким образом, алгоритм выдаёт ложное срабатывание на
данном примере.

Для решения проблемы предлагается использовать дополнительной правило
для вычисления define range. Предположим, что значение $x$ определено
как $\phi(a, b)$, при этом $b = f(x)$. Пусть $f$ удовлетворяет
условию, что последовательность $a, f(a), f(f(a)), \dots$ ---
монотонна (не умаляя общности, предположим, что последовательность
возрастает). Нетрудно видеть, что в таком случае множество возможных
значений $x$ содержится в $\{f^i(a) : i \in [0 .. \inf)\}$ и что все
элементы этого множество не меньше $a$.  Тогда для вычисления define
range $x$ применяется условие $x \geq a$. Примером такой функции $f$
является прибавление или вычитание значения с постоянным знаком.

За счёт использования описанного выше правила в приведённом примере
define range переменной $x$ будет $[0, 10]$, т. к. прибавление единицы
удовлетворяет сформулированному выше условию. Таким образом, в данном
случае удаётся избежать ложного срабатывания.

\subsection{Обработка предиката «не равно»}

\begin{figure}
    \includegraphics[]{for-ne.png}
    \caption{Цикл с условием «не равно»: C++}
    \label{fig:for-ne-cpp}
\end{figure}

\begin{figure}
    \inputTikZ{for-ne}
    \caption{Цикл с условием «не равно»: SSA форма}
    \label{fig:for-ne-ssa}
\end{figure}

На рисунке~\ref{fig:for-ne-cpp} представлен фрагмент C++ кода с
циклом, аналогичным представленному на
рисунке~\ref{fig:for-trivial-cpp}, но в котором значение счётчика
ограничено с помощью условия «не равно». Такие циклы очень часто
встречаются в программах.  На рисунке~\ref{fig:for-ne-ssa}
представлена соответствующая ему SSA форма.

Подход из статьи~\cite{li2010practical} учитывает предикат $x \neq y$
при вычислении use range переменной $v$ только в том случае, если
равенство $x = y$ выполняется для граничного значения $v$. В таком
случае диапазон значений $v$ сокращается на одно значение. Из-за этого
алгоритм неспособен корректно обрабатывать циклы, в которых значение
счётчика ограничено таким предикатом. В примере на
рисунке~\ref{fig:for-ne-ssa} диапазон значений $x$ без учёта предиката $x \neq
10$ будет $[0, \top]$. Равенство $x = 10$ не соответствует
граничному значению, значит, предикат будет проигнорирован. В
результате алгоритм посчитает, что запись в массив может выйти за
границы, хотя можно видеть, что это не так.

Решение данной проблемы похоже на решение предыдущей проблемы и
заключается в введении дополнительного правила для вычисления use
range. Предположим, что значение $x$ определено как $\phi(a, b)$, при
этом $b = f(x)$. Пусть $f$ снова удовлетворяет условию, что
последовательность $a, f(a), f(f(a)), \dots$ --- монотонна (опять
считаем, что последовательность возрастает). Предположим, что условие
$x \neq y$ всегда выполняется в инструкции $P$, для которой
вычисляется use range переменной $x$. Пусть существует такое $c$, что
$y = f^c(a)$. Нетрудно видеть, что последовательность значений $x$
задаётся как $x_i = f^i(a)$. Из условия существования $c: y = f^c(a)$
и предиката $x \neq y$ следует, что всего может быть не более чем $c$
значений $x$. Из свойства функции $f$ следует, что $x < f^c(a) =
y$. Таким образом, при вычислении use range применяется предикат
$x < y$.

В примере на рисунке~\ref{fig:for-ne-ssa} $f(x) = x + 1$, $y = 10$,
$a = 0$, $c = 10$. Таким образом, анализатор способен вывести, что
$x < 10$, за счёт чего обращение к массиву будет обработано корректно.

\FloatBarrier

\section{Учёт предикатов}

\begin{figure}
    \includegraphics[]{predicates-improvement.png}
    \caption{Цикл с дополнительным условием внутри: C++}
    \label{fig:predicates-improvement-cpp}
\end{figure}

\begin{figure}
    \inputTikZ{predicates-improvement}
    \caption{Цикл с дополнительным условием внутри: SSA форма}
    \label{fig:predicates-improvement-ssa}
\end{figure}

В цикле, представленном на
рисунке~\ref{fig:predicates-improvement-cpp} значение переменной $x$,
использующейся как индекс при записи в массив, дополнительно
ограничено числом $7$. Таким образом, значение счётчика цикла
находится в диапазоне $[0, 9]$, однако значение индекса не превышает
$7$. Программа в SSA форме представлена на
рисунке~\ref{fig:predicates-improvement-ssa}.

Проблема подхода~\cite{li2010practical} состоит в правиле,
определяющем, какие предикаты должны учитываться при вычислении use
range переменной $v$ в инструкции $P$. Во-первых, условный переход,
использующий предикат, должен доминировать инструкцию $P$, то есть все
пути из входа в функцию в $P$ должны проходить через
предикат. Во-вторых, $P$ должна быть достижима только из одного
потомка условного перехода. Однако, как нетрудно видеть из
рисунка~\ref{fig:predicates-improvement-ssa}, в данном случае
инструкция записи в массив достижима из обоих потомков условного
перехода. Это приводит к тому, что условие $x < 7$ не применяется для
вычисления use range $x$ в месте записи в массив, из-за чего
анализатор выдаёт несуществующую ошибку.

Описанная проблема может быть решена модификацией второго правила,
определяющего, должен ли учитываться предикат при вычислении use
range. Модифицированное правило ослабляет требование, что инструкция
$P$ должна быть достижима только из одного потомка условного перехода,
использующего предикат. Ослабленное требование заключается в том, что
должен быть ровно один потомок $S$ условного перехода $C$, такой что
$P$ достижима из $C$, игнорируя все рёбра из $C$, кроме
$C \rightarrow S$. В таком случае условие, соответствующее переходу в
$S$, считается выполненым.

Покажем, что предложенная модификация сохраняет
корректность. Рассмотрим произвольный путь в инструкцию $P$. По
первому правилу $P$ доминируется $C$, а значит, путь обязан пройти
через $C$. Рассмотрим последнее ребро на этом пути, исходящее из
$C$. Пусть это ребро $C \rightarrow T$. Если $T = S$, значит, условие,
соответствующее переходу в $S$, выполнено, что и требовалось
доказать. Если же $T \neq S$, то путь в $P$ проходит по другому ребру
из $C$, а значит, предположение о том, что ребро $C \rightarrow T$
является последним на пути, неверно.

При использовании модифицированного правила предикат $x < 7$ будет
учтён в месте записи в массив, т. к. из вершины $x_1 = x + 1$ нет
пути, не проходящего по ребру, соответствующему условию $x < 7$. Таким
образом, предложенная модификация позволяет избавиться от ложного
срабатывания в приведённом примере, при этом сохраняя общую
корректность анализа.

\FloatBarrier

\section{Межпроцедурный анализ}

Одним из главных недостатков подхода~\cite{li2010practical} является
отсутствие межпроцедурного анализа. Каждая функция анализируется
независимо, информация о возможных значениях аргументов
игнорируется. На практике программы обычно состоят из большого числа
маленьких функций, и анализа одной изолированной функции недостаточно,
чтобы точно определить, всегда ли обращение к массиву корректно.

В данной работе анализ был расширен до межпроцедурного. Для этого
функции анализируются в порядке топологической сортировки: от
вызывающей к вызываемой. Если в графе вызовов есть цикл, то
топологическая сортировка неопределена, в таком случае цикл
разрывается в случайных местах. При вызове функции в глобальный
контекст программы записываются диапазоны значений (use ranges)
аргументов, передаваемых в функцию. Рассматриваются целочисленные
аргументы, а также указатели, для которых запоминается размер буфера
(массива). При повторном вызове функции диапазоны аргументов
объединяются с уже сохранёнными.  Таким образом, при анализе функции
для её аргументов известны диапазоны возможных значений. Если функция
ни разу не вызывалась, то анализатор считает, что её аргументы могут
принимать любые значения.

\FloatBarrier

\chapterconclusion

В главе 2 представлены результаты исследования алгоритма,
описанного в статье~\cite{li2010practical}. В ходе исследования были
выявлены различные недостатки алгоритма, которым было уделено внимание
в данной работе. Показаны примеры кода, когда алгоритм работает
некорректно, предложены модификации исходного алгоритма, направленные
на устранение выявленных проблем. Доказана корректность предложенных
модификаций.
