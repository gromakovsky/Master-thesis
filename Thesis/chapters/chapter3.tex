%-*-coding: utf-8-*-
\chapter{Практическая реализация и результаты}

\section{Реализация}

Предложенный подход был реализован на языке C++.  Как и в
статье~\cite{li2010practical}, было принято решение анализировать не
исходный код на C/C++, а промежуточное представление
LLVM~\cite{lattner2004llvm}. У такого подхода есть несколько весомых
преимуществ~\cite{merz2012llbmc}. Во-первых, LLVM-IR состоит из более
простых языковых конструкций, нежели C или тем более C++, что упрощает
анализ и позволяет охватить большее число возможностей языка с
меньшими усилиями. Во-вторых, код LLVM-IR представляет из себя
результат работы компилятора и является очень близким к тому, что
будет реально выполняться. Это позволяет найти ошибки, появившиеся в
результате трансформаций, выполняемых компилятором. Также
инфраструктура LLVM содержит огромное число встроенных оптимизаций,
средств для анализа и т. п., что можно использовать при
реализации. Ещё одним преимуществом анализа LLVM-IR является то, что
за счёт этого автоматически поддерживается любой язык, для которого
есть компилятор в LLVM-IR, не только C и C++ (являющиеся примерами
таких языков). Также стоит отметить, что программа в LLVM-IR всегда
представлена в SSA форме, на которой базируется описанный ранее
алгоритм. Альтернативное решение состоит в построении SSA формы для
исходной программы на C/C++ и её анализе, однако было показано, что
анализ LLVM-IR имеет существенные преимущества. Язык C++ был выбран
для реализации анализатора преимущественно по двум
причинам. Во-первых, библиотека LLVM написана на C++ и может быть
использована напрямую. Для большого числа популярных языков написаны
интерфейсы вызова сторонних функций библиотеки LLVM, однако они могут
быть неполными или устаревшими. Во-вторых, за счёт использования C++
проще достичь высокой производительности.

Изначально подход из статьи~\cite{li2010practical} был реализован в
полном соответствии с описанием. После этого были найдены недостатки и
разработаны способы их устранения, описанные в предыдущей главе.

\subsection{LLVM}

В LLVM каждое значение ($llvm::Value$) идентифицируется обычным
указателем ($llvm::Value *$), поэтому диапазоны переменных
ассоциируются с указателями на значения. Для идентификации инструкций
в рамках use range используются указатели на базовые блоки
($llvm::BasicBlock$), поскольку use range переменной одинаков во всех
инструкциях из одного базового блока. Для выявления инструкций,
выделяющих блоки памяти, использовалась функция $isAllocationFn$ из
LLVM. Размер массива вычисляется как число байт, выделяемых такой
функций, поделённое на размер типа данных в массиве. Информация о
размере типа в байтах также предоставляется LLVM. В качестве
инструкций, обращающихся к памяти, рассматриваются $store$ и
$load$. Анализатор начинает вычисление диапазонов, только встретив
одну из этих инструкций, то есть анализ выполняется «по требованию».

Также LLVM предоставляет полезные функции и классы для расчёта use
range. Для проверки того, что инструкция доминируется предикатным
узлом, необходимой для уточнения use range, используется
$llvm::DominatorTree$, с помощью которого можно проверять предикат
доминируемости. Другая функциональность, необходимая для уточнения
диапазона значений, заключается в проверке достижимости одного
базового блока из другого. В общем случае такая проверка невозможна,
однако в LLVM есть функция $llvm::isPotentiallyReachable$, которая
возвращает $false$, если базовый блок точно недостижим, и $true$ в
противном случае. Как было показано в предыдущей главе, простая
проверка достижимости не является достаточно точной и может приводить
к неправильным результатам. При более точном подходе необходимо
игнорировать рёбра из $C$, кроме ребра $C \rightarrow S$. Поэтому
использовалась модифицированная версия функции, игнорирующая такие
рёбра.

При обнаружении ошибки о ней необходимо сообщить пользователю в
понятном формате. Для этого нужно сопоставлять инструкции из
промежуточного представления LLVM выражениям в исходном коде на
высокоуровневом языке. Эта проблема решается за счёт использования
отладочной информации, генерируемой компилятором при использовании
специального флага. В LLVM такая информация представлена классом
$DebugLoc$. Если программа скомпилирована с отладочной информацией, то
по инструкции LLVM можно получить её $DebugLoc$ и сообщить
пользователю, где в исходном коде находится ошибка.

\subsection{Gated Single Assignment}

Одной из наиболее важных деталей алгоритма является использование
Gated Single Assignment формы
(GSA)~\cite{ottenstein1990program}. Отличие этой формы от SSA
заключается в том, что аргументы $\phi$-инструкций также содержат
условия, которые гарантировано выполняются, если данное значение
возвращается $\phi$-инструкцией. Это позволяет существенно повысить
точность анализа, отбрасывая невозможные значения переменных.

В реализации анализатора использовался алгоритм для конвертации SSA
формы в GSA, предложенный в статье~\cite{tu1995efficient}. Данный
алгоритм является одним из наиболее простых в реализации. Он не
требует, чтобы исходная программа была в SSA, однако существенно
упрощается, если это выполнено. В основе алгоритма лежит понятие
«выражение пути» (path expression), которое является регулярным
выражением над алфавитом, состоящем из рёбер в графе потока
управления. Пути, приходящие в $\phi$-инструкцию, представляются
выражениями пути. В конце работы алгоритма выражения пути превращаются
в предикаты GSA-формы. Несмотря на свою простоту, алгоритм также
является более эффективным по сравнению со своими аналогами. В
результате работы алгоритма для каждого операнда каждой
$\phi$-инструкции известен определённый набор условий, который должны
выполняться, чтобы данное значение было результатом $\phi$-инструкции.

TODO: expand this subsection, add more subsections (at least one more
about something general).

\section{Экспериментальные результаты}

TODO

\section{Сравнение}

Также было проведено сравнение анализатора с другими доступными
анализаторами C/C++ кода. Использовались следующие анализаторы: Clang
Analyzer, CppCheck, PVS-Studio, Splint, а также реализация
анализатора, описанного в статье~\cite{li2010practical}, и реализация
предложенного подхода. Для сравнения использовался набор синтетических
тестов, представленных в листинге~\ref{lst:comparison}.

\begin{table}[!h]
\caption{Результаты сравнения анализаторов}\label{tab:comparison}
\centering
% \begin{tabu}{|*{18}{X[c]|}}\hline
%   --                 & TP  & FP & FN \\\hline
%   Clang Analyzer     & 0   & 0  & 0  \\\hline
%   CppCheck           & 3   & 0  & 9  \\\hline
%   PVS-Studio         & 4   & 0  & 8  \\\hline
%   Splint             & 9   & 3  & 3  \\\hline
%   Li et at.          & 12  & 8  & 0  \\\hline
%   Предложенный метод & 12  & 0  & 0  \\\hline
% \end{tabu}
  \begin{tabular}{|*{18}{c|}}\hline
  --                 & TP  & FP & FN \\\hline
  Clang Analyzer     & 0   & 0  & 0  \\\hline
  CppCheck           & 3   & 0  & 9  \\\hline
  PVS-Studio         & 4   & 0  & 8  \\\hline
  Splint             & 9   & 3  & 3  \\\hline
  Li et at.          & 12  & 8  & 0  \\\hline
  Предложенный метод & 12  & 0  & 0  \\\hline
  \end{tabular}
\end{table}

В таблице~\ref{tab:comparison} представлены результаты сравнения.

\chapterconclusion

В данной главе была вкратце описана реализация предложенного
подхода. Приведены экспериментальные результаты запуска анализатора на
крупных проектах. Показано, что анализатор способен находить в них
ошибки, работая за приемлимое время. Также было проведено сравнение с
доступными статическими анализаторами C/C++ кода на наборе тестов,
представленных в листинге~\ref{lst:comparison}. Продемонстрировано
превосходство над представленными анализаторами на данном наборе
тестов.
