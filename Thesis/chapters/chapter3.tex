%-*-coding: utf-8-*-
\chapter{Практическая реализация и результаты}

\section{Реализация}

Предложенный подход был реализован на языке C++.  Как и в
статье~\cite{li2010practical}, было принято решение анализировать не
исходный код на C/C++, а промежуточное представление
LLVM~\cite{lattner2004llvm}. У такого подхода есть несколько весомых
преимуществ~\cite{merz2012llbmc}. Во-первых, LLVM-IR состоит из более
простых языковых конструкций, нежели C или тем более C++, что упрощает
анализ и позволяет охватить большее число возможностей языка с
меньшими усилиями. Во-вторых, код LLVM-IR представляет из себя
результат работы компилятора и является очень близким к тому, что
будет реально выполняться. Это позволяет найти ошибки, появившиеся в
результате трансформаций, выполняемых компилятором. Также
инфраструктура LLVM содержит огромное число встроенных оптимизаций,
средств для анализа и т. п., что можно использовать при
реализации. Ещё одним преимуществом анализа LLVM-IR является то, что
за счёт этого автоматически поддерживается любой язык, для которого
есть компилятор в LLVM-IR, не только C и C++ (являющиеся примерами
таких языков). Также стоит отметить, что программа в LLVM-IR всегда
представлена в SSA форме, на которой базируется описанный ранее
алгоритм. Альтернативное решение состоит в построении SSA формы для
исходной программы на C/C++ и анализе её, однако было показано, что
анализ LLVM-IR имеет существенные преимущества. Язык C++ был выбран
для реализации анализатора преимущественно по двум
причинам. Во-первых, библиотека LLVM написана на C++ и может быть
использована напрямую. Во-вторых, за счёт использования C++ проще
достичь высокой производительности.

Изначально подход из статьи~\cite{li2010practical} был реализован в
полном соответствии с описанием. После этого были найдены недостатки и
разработаны способы их устранения, описанные в предыдущей главе.

\subsection{LLVM}

В LLVM каждое значение ($Value$) идентифицируется указателем
($Value *$), поэтому диапазоны переменных ассоциировались с
указателями на значения. Для идентификации инструкций в рамках use
range использовались указатели на базовые блоки, поскольку use range
переменной одинаков во всех инструкциях из одного базового блока. Для
выявления инструкций, выделяющих блоки памяти, использовалась функция
$isAllocationFn$ из LLVM. Размер массива вычисляется как число байт,
выделяемых такой функций, поделённое на размер типа данных в массиве.

TODO

\subsection{Gated Single Assignment}

Одной из наиболее важных деталей алгоритма является использование
Gated Single Assignment формы
(GSA)~\cite{ottenstein1990program}. Отличие этой формы от SSA
заключается в том, что аргументы $\phi$-инструкций также содержат
условия, которые гарантировано выполняются, если данное значение
возвращается $\phi$-инструкцией. Это позволяет существенно повысить
точность анализа, отбрасывая невозможные значения переменных.

В реализации анализатора использовался алгоритм для конвертации SSA
формы в GSA, предложенный в статье~\cite{tu1995efficient}. Данный
алгоритм является одним из наиболее простых в реализации. Он не
требует, чтобы исходная программа была в SSA, однако существенно
упрощается, если это выполнено. В основе алгоритма лежит понятие
«выражение пути» (path expression), которое является регулярным
выражением над алфавитом, состоящем из рёбер в графе потока
управления. Пути, приходящие в $\phi$-инструкцию, представляются
выражениями пути. В конце работы алгоритма выражения пути превращаются
в предикаты GSA-формы. Несмотря на свою простоту, алгоритм также
является более эффективным по сравнению со своими аналогами. В
результате работы алгоритма для каждого операнда каждой
$\phi$-инструкции известен определённый набор условий, который должны
выполняться, чтобы данное значение было результатом $\phi$-инструкции.

TODO: expand this subsection, add more subsections (at least one more
about something general).

\section{Экспериментальные результаты}

TODO

\section{Сравнение}

Также было проведено сравнение анализатора с другими доступными
анализаторами C/C++ кода. Использовались следующие анализаторы: Clang
Analyzer, CppCheck, PVS-Studio, Splint, а также реализация
анализатора, описанного в статье~\cite{li2010practical}, и реализация
предложенного подхода. Для сравнения использовался набор синтетических
тестов, представленных в листинге~\ref{lst:comparison}.

\begin{table}[!h]
\caption{Результаты сравнения анализаторов}\label{tab:comparison}
\centering
% \begin{tabu}{|*{18}{X[c]|}}\hline
%   --                 & TP  & FP & FN \\\hline
%   Clang Analyzer     & 0   & 0  & 0  \\\hline
%   CppCheck           & 3   & 0  & 9  \\\hline
%   PVS-Studio         & 4   & 0  & 8  \\\hline
%   Splint             & 9   & 3  & 3  \\\hline
%   Li et at.          & 12  & 8  & 0  \\\hline
%   Предложенный метод & 12  & 0  & 0  \\\hline
% \end{tabu}
  \begin{tabular}{|*{18}{c|}}\hline
  --                 & TP  & FP & FN \\\hline
  Clang Analyzer     & 0   & 0  & 0  \\\hline
  CppCheck           & 3   & 0  & 9  \\\hline
  PVS-Studio         & 4   & 0  & 8  \\\hline
  Splint             & 9   & 3  & 3  \\\hline
  Li et at.          & 12  & 8  & 0  \\\hline
  Предложенный метод & 12  & 0  & 0  \\\hline
  \end{tabular}
\end{table}

В таблице~\ref{tab:comparison} представлены результаты сравнения.

\chapterconclusion

В данной главе была вкратце описана реализация предложенного
подхода. Приведены экспериментальные результаты запуска анализатора на
крупных проектах. Показано, что анализатор способен находить в них
ошибки, работая за приемлимое время. Также было проведено сравнение с
доступными статическими анализаторами C/C++ кода на наборе тестов,
представленных в листинге~\ref{lst:comparison}. Продемонстрировано
превосходство над представленными анализаторами на данном наборе
тестов.
