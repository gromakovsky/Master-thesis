\documentclass[russian, hyperref={unicode}]{beamer}

\usetheme{Madrid}
\setbeamertemplate{footline}[frame number]
\setbeamertemplate{navigation symbols}{}
\setbeamerfont{note page}{size=\footnotesize}
\setbeamertemplate{note page} {%
  \hbox{\insertshortframetitle[width=8cm]}%
  \vskip1.75em
  \nointerlineskip
  \insertnote
}

% \setbeameroption{show only notes}

\usepackage[T2A]{fontenc}
\usepackage{lmodern}
\usepackage[utf8x]{inputenc}
\usepackage[english, russian, main=russian]{babel}
\usepackage{graphicx}

\usepackage{algpseudocode}
\algtext*{EndWhile}     % Remove "end while" text
\algtext*{EndFor}       % Remove "end for" text
\algtext*{EndFunction}  % Remove "end function" text
\algtext*{EndIf}        % Remove "end if" text

\graphicspath{ {../Images/} }

% workaround warning
\let\Tiny=\tiny

\title{Разработка алгоритмов статического поиска выходов за пределы
  динамического массива в С/C++ программах}
\author{И. Е. Громаковский \\
  {\small Научный руководитель: М. А. Лукин}}
\institute{Санкт-Петербургский национальный исследовательский
  университет \\ информационных технологий, механики и оптики}
\date{}

\begin{document}

\section{Введение}

\frame{\titlepage}
\note{Здравствуйте!}

\subsection{Решаемая проблема}

\begin{frame}{Описание задачи}
    \begin{itemize}
        \item Статический поиск выходов за пределы динамического
          массива в C и C++
        \item Работа с большими программами за разумное время
        \item В общем случае задача поиска всех выходов неразрешима
    \end{itemize}
\end{frame}
\note {
  Как видно из названия, в рамках данной работы требуется находить
  выходы за пределы динамического массива в программах на C и
  C++. Делать это нужно статически, что позволяет найти ошибки до
  того, как они проявят себя. Требуется уметь обрабатывать большие
  программы (состоящие из сотен тысяч строк) за разумное время. В
  общем случае задача поиска всех выходов за пределы массива
  неразрешима, поэтому все решения являются эвристическими и
  отличаются в точности анализа и масштабируемости.
}

\begin{frame}{Актуальность проблемы}
    \begin{itemize}
        \item Программное обеспечение всегда было и остаётся
          подвержено ошибкам в коде
        \item Выход за пределы массива — одна из главных уязвимостей с
          точки зрения безопасности
        \item Особенно опасны ошибки в операционных системах, для
          которых популярны языки C и C++
    \end{itemize}
\end{frame}
\note {
  Данная проблема является крайне актуальной, поскольку программное
  обеспечение всегда было и остаётся подвержено ошибкам в
  коде. Известно большое число примеров, когда ошибки в коде
  приводили к ужасным последствиям. Ошибки, ведущие к выходу за
  пределы массива в C/C++, являются одной из главных уязвимостей с
  точки зрения безопасности. В некоторых случаях злоумышленник может,
  используя такие уязвимости, получить полный контроль над
  системой. Стоит отметить, что особую опасность представляют такие
  ошибки в коде операционных систем, виртуальных машин и прочих
  низкоуровневых программ. Они зачастую пишутся на C/C++, что
  усиливает актуальность проблемы.
}

\subsection{Обзор существующих решений}

\begin{frame}{Существующие решения}
    \begin{itemize}
        \item Использование аннотаций (Dor et al., 2003)
        \item Вывод ограничений
          \begin{itemize}
            \item Обход путей программы, построение логического
              утверждения (Ganapathy et al., 2003)
            \item Анализ по требованию (Le et al., 2008)
          \end{itemize}
        \item Анализ промежуточного представления (Li et al., 2010)
    \end{itemize}
\end{frame}
\note {
  Среди существующих решений можно выделить некоторые общие
  подходы. Например, некоторые подходы используют пользовательские
  аннотации для упрощения проверки корректности доступа к
  памяти. Однако для больших программ такой подход требует слишком
  больших человеческих усилий для написания аннотаций, поэтому он
  практически не применим. Большинство известных подходов выводят
  ограничения различных значений в программе и делают вывод о наличии
  ошибок, исходя из этих ограничений. Один из вариантов заключается в
  обходе всех путей программы и построении системы, ограничивающей
  возможные значения переменных, а также логического утверждения,
  соответствующего отсутствию ошибок. После этого используется
  SMT-solver для проверки выполнимости этого утверждения. При большом
  числе ветвлений такой подход работает неприемлемо. Более современные
  подходы используют анализ по требованию, основная идея которого
  состоит в том, чтобы рассматривать только пути программы, которые
  влияют на обращения к массиву. Вместо описания программы в целом,
  каждое обращение обрабатывается отдельно, что на практике
  существенно уменьшает объём вычислений. Также стоит отметить
  использование промежуточного представления, например, представление
  LLVM, для анализа.
}

\section{Результаты}

\begin{frame}{Результаты}
    \begin{itemize}
        \item Умею
        \item Могу
    \end{itemize}
\end{frame}
\note {
  Типа вот вам результаты, всё круто, я хорош.
}

\begin{frame}{Спасибо за внимание!}
    \begin{center}
        \Huge
        {\color{blue} Вопросы?}
    \end{center}
\end{frame}
\note{До свидания!}

\appendix

\begin{frame}[noframenumbering, t]{Обоснование метрик}
    \only<1> {
      kek
    }
    \only<2> {
      хи-хи
    }
\end{frame}

\end{document}
